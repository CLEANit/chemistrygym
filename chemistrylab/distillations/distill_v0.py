'''
Module to perform actions to isolate a desired material generated in a Wurtz reaction.

:title: distill_v0.py

:author: Mitchell Shahen

:history: 2020-07-22

Available Actions for this Distillation Experiment are included below.

0: Add/Remove Heat (Heat value multiplier, relative of maximal heat change)
1: Pour BV into B1 (Volume multiplier, relative to max_vessel_volume)
2: Pour B1 into B2 (Volume multiplier, relative to max_vessel_volume)
3: Pour B1 into BV (Volume multiplier, relative to max_vessel_volume)
4: Pour B2 into BV (Volume multiplier, relative to max_vessel_volume)
5: Done (Value doesn't matter)
'''

import gym
import sys

sys.path.append("../../")
from chemistrylab.chem_algorithms import vessel, util

class Distillation:
    '''
    '''

    def __init__(
        self,
        boil_vessel,
        target_material,
        n_empty_vessels=2,
        n_actions=6, # number of available actions
        dt=0.05, # default time step
        dQ=1, # maximal change in heat
        max_vessel_volume=1000.0 # maximal volume of empty vessels
    ):
        '''
        '''

        self.n_actions = n_actions
        self.n_empty_vessels = n_empty_vessels
        self.n_total_vessels = n_empty_vessels + 1

        self.target_material = target_material

        self.dt = dt
        self.dQ = dQ

        self.max_vessel_volume = max_vessel_volume

    def get_action_space(self):
        '''
        '''

        # actions have two values:
        #   action[0] is the index of the action to perform
        #   action[1] is a multiplier for how much to do of that action
        action_space = gym.spaces.MultiDiscrete([self.n_actions, 10])

        return action_space

    def reset(self, boil_vessel):
        '''
        '''

        # add the inputted boil vessel to the list of all vessels
        vessels = [boil_vessel]

        # create the empty beaker vessels, set variables to default values
        for i in range(self.n_empty_vessels):
            beaker = vessel.Vessel(
                label="beaker_{}".format(i),
                v_max=self.max_vessel_volume,
                default_dt=self.dt
            )
            vessels.append(beaker)

        # generate the state
        state = util.generate_state(
            vessel_list=vessels,
            max_n_vessel=self.n_total_vessels
        )

        return vessels, state

    def perform_action(self, vessels, action):
        '''
        Method to perform the action designated by `action` and update
        the state, vessels, external vessels, and generate reward.

        Parameters
        ---------------
        `vessels` : `list`
            A list of all the vessel objects that contain materials and solutes.
        `action` : `list`
            A list of two numbers indicating the index of an action to
            perform and a multiplier used when performin the action.

        Returns
        ---------------
        `vessels` : `list`
            A list of all the vessel objects that contain materials and solutes.
        `external_vessels` : `list`
            A list of the external vessels, beakers, to be used in the extraction.
        `reward` : `float`
            The amount of the target material that has been generated by the most recent action.
        `done` : `bool`
            A boolean indicating if all of the required actions have now been completed.

        Raises
        ---------------
        None
        '''

        # deconstruct the action
        do_action = int(action[0])
        multiplier = int(action[1])

        # if the multiplier is 0, only actions 0 (heat change) and 5 (done) can be performed
        if all([multiplier == 0, do_action not in [0, 5]]):
            for vessel_obj in vessels:
                __ = vessel_obj.push_event_to_queue(dt=self.dt)
        else:
            # obtain the necessary vessels
            boil_vessel = vessels[0]
            beaker_1 = vessels[1]
            beaker_2 = vessels[2]

            # Add/Remove Heat (Heat multiplier)
            if do_action == 0:
                # calculate the amount of heat being added/removed
                multiplier = 2 * (multiplier/10 - 0.5)
                heat_change = multiplier * self.dQ

                # add the event to perform the heat change
                event = ['change heat', heat_change]

                # push the event to the extraction vessel
                reward = boil_vessel.push_event_to_queue(events=[event], dt=self.dt)

                # push no events to either beaker
                __ = beaker_1.push_event_to_queue(dt=self.dt)
                __ = beaker_2.push_event_to_queue(dt=self.dt)

            # pour the Boil Vessel into Beaker 1
            if do_action == 1:
                # determine the volume to pour
                d_volume = boil_vessel.get_max_volume() * multiplier/10

                # push the event to the boil vessel
                event = ['pour by volume', beaker_1, d_volume]
                reward = boil_vessel.push_event_to_queue(events=[event], dt=self.dt)

                # push no events to the second beaker
                __ = beaker_2.push_event_to_queue(dt=self.dt)

            # Pour Beaker 1 into Beaker 2
            if do_action == 2:
                # determine the volume to pour
                d_volume = beaker_1.get_max_volume() * multiplier/10

                # push the event to the first beaker
                event = ['pour by volume', beaker_2, d_volume]
                reward = beaker_1.push_event_to_queue(events=[event], dt=self.dt)

                # push no events to the first beaker
                boil_vessel.push_event_to_queue(dt=self.dt)

            # Pour Beaker 1 into the boil vessel
            if do_action == 3:
                # determine the volume to pour
                d_volume = beaker_1.get_max_volume() * multiplier/10

                # push the event to the first beaker
                event = ['pour by volume', boil_vessel, d_volume]
                reward = beaker_1.push_event_to_queue(events=[event], dt=self.dt)

                # push no events to the second beaker
                beaker_2.push_event_to_queue(dt=self.dt)

            # Pour Beaker 2 into the boil vessel
            if do_action == 4:
                # determine the volume to pour
                d_volume = beaker_2.get_max_volume() * multiplier/10

                # push the event to the second beaker
                event = ['pour by volume', boil_vessel, d_volume]
                reward = beaker_2.push_event_to_queue(events=[event], dt=self.dt)

                # push no events to the first beaker
                beaker_1.push_event_to_queue(dt=self.dt)

            # Indicate that all no more actions are to be completed
            if do_action == 5:
                # pass the fulfilled `done` parameter
                done = True

                # look through each vessel's material dict looking for the target material
                reward = 0
                for in_vessel in vessels:
                    material_names = in_vessel._material_dict.keys()
                    if self.target_material in material_names:
                        reward += self.done_reward(in_vessel)

        return vessels, reward, done

    def done_reward(self, beaker):
        '''
        Method to calculate the full reward once the final action has taken place.

        Parameters
        ---------------
        `beaker` : `vessel.Vessel`
            A vessel object that contains all of the extracted materials and solutes.

        Returns
        ---------------
        `reward` : `float`
            The amount of the target material that has been generated by the most recent action.

        Raises
        ---------------
        None
        '''

        # get the name of the vessel object containing the target material
        label = beaker.label

        # extract the material dictionary from the vessel object
        materials = beaker._material_dict

        # obtain the names and value lists from the material dictionary
        material_names = materials.keys()
        values = materials.values()

        # get the index and then amount of the target material in the material dictionary
        target_material_index = material_names.index(self.target_material)
        target_material_amount = values[target_material_index][1]

        # sum the amounts of all materials in the material dictionary
        total_material_amount = 0
        for value_list in values:
            material_amount = value_list[1]
            total_material_amount += material_amount

        # calculate the reward as the purity of the target material in the vessel
        reward = target_material_amount/total_material_amount

        # print the results to the terminal
        print("Done Reward in {}:".format(label))
        print("----- Target Material Amount = {} -----".format(target_material_amount))
        print("----- Total Material Amount = {} -----".format(total_material_amount))
        print("----- Reward = {} -----".format(reward))

        return reward
